class CryptoKeyJS{static#e='Invalid SHA-x';static#r='Invalid algorithm';static#t=['ECDSA','ECDH','RSA-PSS','RSA-OAEP','RSASSA-PKCS1-v1_5','Ed25519','X25519'];static#a=['sign','decrypt','deriveBits','deriveKey'];#s;#n;#i;#o;constructor(e,r,t,a){if('string'==typeof a?.error)throw new Error(a.error);if(r&&(e.name||e).indexOf('KDF')>-1)throw new DOMException('KDF keys must set extractable=false');const s=this;s.#s=e,s.#n=r,s.#i=t,s.#o=a}get extractable(){return this.#n}get isAsync(){return CryptoKeyJS.#t.indexOf(this.#c)>-1}get isPublic(){const e=this;return!!e.isAsync&&(0===e.#i.length||['verify','encrypt'].some((r=>e.#i.includes(r))))}get isPrivate(){const e=this;return!!e.isAsync&&CryptoKeyJS.#a.some((r=>e.#i.includes(r)))}get type(){return this.isAsync?this.isPrivate?'private':'public':'secret'}get algorithm(){return'string'==typeof this.#s?this.#s:Object.assign({},this.#s)}get usages(){return Array.from(this.#i)}get crypto(){return globalThis.CryptoWasm.gc=!0,globalThis.CryptoWasm}get#y(){const e=this.#s;return e.hash?.name||e.hash||e.namedCurve}get#c(){return this.#s.name||this.#s}get#h(){return CryptoKeyJS.hashSize(this.#y)}get#S(){return this.#A(this.#y)}get#u(){const e=this,r=e.#S;if(e.isAsync){switch(e.#c){case'RSASSA-PKCS1-v1':return`RS${r}`;case'RSA-OAEP':return 1===r?'RSA-OAEP':`RSA-OAEP-${r}`;case'RSA-PSS':return`PS${r}`}return null}return'HMAC'===e.#c?`HS${e.#s.length||e.#S}`:`A${e.#s.length}${e.#c.split('-')[1]}`}#A(e=''){return parseInt(e.split('-')[1])}#p(e,r){if(!this.#n)throw new DOMException('InvalidAccessError');if(r.indexOf(e)<0)throw new DOMException('NotSupported')}#l(e){return this.#p(e,['pkcs8','spki','jwk','raw'])}#E(e){const r=this;return r.#p(e,['raw','jwk']),'raw'===e?r.#o:{alg:r.#u,ext:!0,k:r.crypto.toB64(r.#o,!0),key_ops:r.#i,kty:'oct'}}#w(e,r){const t=this;t.#l(e);let a=0;switch(e){case'raw':a=0;break;case'jwk':a=2;break;case'spki':a=1;case'pkcs8':a=1}const s=r.ExportKey(t.#o,t.isPublic,a);if('raw'===e)return s;if('jwk'===e){s.key_ops=t.#i;0===t.#c.indexOf('RSA')&&(s.alg=t.#u)}return s}#d(e){const r=this,t=r.crypto.hmac,a=r.#y;switch(a){case'SHA-1':return t.Hmac1Sign(e,r.#o);case'SHA-256':return t.Hmac256Sign(e,r.#o);case'SHA-384':return t.Hmac384Sign(e,r.#o);case'SHA-512':return t.Hmac512Sign(e,r.#o);default:throw new Error(`${CryptoKeyJS.#e} : ${a}`)}}#g(e,r){const t=this,a=t.crypto.hmac,s=t.#y;switch(s){case'SHA-1':return a.Hmac1Verify(r,e,t.#o);case'SHA-256':return a.Hmac256Verify(r,e,t.#o);case'SHA-384':return a.Hmac384Verify(r,e,t.#o);case'SHA-512':return a.Hmac512Verify(r,e,t.#o);default:throw new Error(`${CryptoKeyJS.#e} : ${s}`)}}#m(e){const r=this;return r.crypto.rsa.SignPKCS1v15(r.#o,e,r.#h)}#f(e,r){const t=this;return t.crypto.rsa.VerifyPKCS1v15(t.#o,r,e,t.#h)}#C(e,r){const t=this,a=r.saltLength||0;return t.crypto.rsa.SignPSS(t.#o,e,t.#h,a)}#K(e,r,t){const a=this,s=t.saltLength||0;return a.crypto.rsa.VerifyPSS(a.#o,r,e,a.#h,s)}#R(e,r){const t=this;if('Ed25519'===t.#s.namedCurve)return t.#v(e);const a=r.hash.name||r.hash,s=t.#A(a);return t.crypto.ecdsa.Sign(t.#o,e,s,!1)}#D(e,r,t){const a=this;if('Ed25519'===a.#s.namedCurve)return a.#k(e,r);const s=t.hash.name||t.hash,n=a.#A(s);return a.crypto.ecdsa.Verify(a.#o,r,e,n,!1)}#v(e){return this.crypto.ed25519.Sign(this.#o,e,!1)}#k(e,r){return this.crypto.ed25519.Verify(this.#o,r,e,!1)}#b(e,r=0){const t=this,a=CryptoKeyJS.curveSize(t.#s.namedCurve);if(r>a||25519===a&&r>256)throw new DOMException('OperationError');if(0===r)return new Uint8Array;const s=t.crypto.ecdh.DeriveKey(t.#o,e.public.#o,r);if('string'==typeof s?.error)throw new Error(s.error);return s}#H(e,r){if(!r||0===r||r%8>0)throw new DOMException('OperationError');return this.crypto.GenerateHKDF(this.#o,e.salt,e.info,r)}#L(e,r){if(0===r)return new Uint8Array;const t=CryptoKeyJS.hashSize(e.hash);return this.crypto.GeneratePBKDF2(this.#o,e.salt,e.iterations,r,t)}#_(e,r,t,a){const s=r.length,n=this.#b(e,s);return new CryptoKeyJS(r,t,a,n)}#I(e,r,t,a){const s=CryptoKeyJS.hashSize(e.hash),n=this.#H(e,s);return new CryptoKeyJS(r,t,a,n)}#P(e,r,t,a){const s=r.length||CryptoKeyJS.hashSize(r.hash),n=this.#L(e,s);return new CryptoKeyJS(r,t,a,n)}deriveBits(e,r){const t=this,a=t.#c,s=e.name===a?e.name:`${e.name} <-> ${a}`;switch(s){case'X25519':case'ECDH':return t.#b(e,r);case'HKDF':return t.#H(e,r);case'PBKDF2':return t.#L(e,r);default:throw new Error(`${CryptoKeyJS.#r} : ${s}`)}}deriveKey(e,r,t,a){const s=this,n=s.#c,i=e.name===n?e.name:`${e.name} <-> ${n}`;switch(i){case'X25519':case'ECDH':return s.#_(e,r,t,a);case'HKDF':return s.#I(e,r,t,a);case'PBKDF2':return s.#P(e,r,t,a);default:throw new Error(`${CryptoKeyJS.#r} : ${i}`)}}sign(e,r){const t=this,a=t.#c;switch(a){case'RSASSA-PKCS1-v1_5':return t.#m(e);case'RSA-PSS':return t.#C(e,r);case'ECDSA':return t.#R(e,r);case'HMAC':return t.#d(e);case'Ed25519':return t.#v(e);default:throw new Error(`${CryptoKeyJS.#r} : ${a}`)}}verify(e,r,t){const a=this,s=a.#c;switch(s){case'RSASSA-PKCS1-v1_5':return a.#f(e,r);case'RSA-PSS':return a.#K(e,r,t);case'ECDSA':return a.#D(e,r,t);case'HMAC':return a.#g(e,r);case'Ed25519':return a.#k(e,r);default:throw new Error(`${CryptoKeyJS.#r} : ${s}`)}}decrypt(e,r){const t=this,a=t.crypto.aes,s=t.#c;switch(s){case'RSA-OAEP':return t.crypto.rsa.Decrypt(t.#o,t.#h,e);case'AES-CTR':return a.CTRDecrypt(t.#o,e,r);case'AES-CBC':return a.CBCDecrypt(t.#o,e,r);case'AES-GCM':return a.GCMDecrypt(t.#o,e,r);default:throw new Error(`${CryptoKeyJS.#r} : ${s}`)}}encrypt(e,r){const t=this,a=t.crypto.aes,s=t.#c;switch(s){case'RSA-OAEP':return t.crypto.rsa.Encrypt(t.#o,t.#h,e);case'AES-CTR':return a.CTREncrypt(t.#o,e,r);case'AES-CBC':return a.CBCEncrypt(t.#o,e,r);case'AES-GCM':return a.GCMEncrypt(t.#o,e,r);default:throw new Error(`${CryptoKeyJS.#r} : ${s}`)}}export(e){const r=this;if(!r.#n)throw new DOMException('InvalidAccessError');const t=r.#c;switch(t){case'AES-CBC':case'AES-CTR':case'AES-GCM':case'HMAC':case'PBKDF2':case'HKDF':return r.#E(e);case'RSASSA-PKCS1-v1_5':case'RSA-OAEP':case'RSA-PSS':return r.#w(e,r.crypto.rsa);case'ECDSA':return r.#w(e,r.crypto.ecdsa);case'ECDH':return r.#w(e,r.crypto.ecdh);case'Ed25519':return r.#w(e,r.crypto.ed25519);default:throw new Error(`${CryptoKeyJS.#r} : ${t}`)}}static curveSize(e){switch(e){case'P-256':return 256;case'P-384':return 384;case'P-521':return 521;case'Ed25519':case'X25519':return 25519;default:throw new Error('Invalid Curve')}}static blockSize(e){let r=0;switch(e){case'SHA-1':case'SHA-256':r=512;break;case'SHA-384':case'SHA-512':r=1024;break;default:throw new Error(`${CryptoKeyJS.#e} : ${e}`)}return r}static hashSize(e){let r=0;switch(e){case'SHA-1':r=20;break;case'SHA-256':r=32;break;case'SHA-384':r=48;break;case'SHA-512':r=64;break;default:throw new Error(`${CryptoKeyJS.#e} : ${e}`)}return r}}class WasmLoader{static RETURN_RAW=!0;static#N=!1;static#x=0;static#J=null;static get ready(){return WasmLoader.#N}static get GOPATH(){return`${globalThis.CRYPTO_GO||''}/wasm_exec.min.js`}static get WASMPATH(){return`${globalThis.CRYPTO_WASM||''}/cryptojs.wasm`}static#O(){WasmLoader.#N=!1,WasmLoader.#x&&clearInterval(WasmLoader.#x),WasmLoader.#x=0}static async init(){if(WasmLoader.#N)return;WasmLoader.#J=null,WasmLoader.#x=0;const e=await WasmLoader.#T(),r=await WasmLoader.#W(WasmLoader.WASMPATH,e.importObject);e.run(r.instance).then((()=>WasmLoader.#O())),WasmLoader.#x=globalThis.CryptoWasm.GCToken(),WasmLoader.#N=!0,WasmLoader.#J={result:r,go:e}}static async#T(){await import(WasmLoader.GOPATH);return new globalThis.Go}static async#W(e,r){if('object'!=typeof WebAssembly||'function'!=typeof WebAssembly.instantiate)throw new Error('WebAssembly is not supported.');return await WebAssembly.instantiateStreaming(fetch(e),r)}static#U(e,r,t){const a=new Blob([e],{type:t}),s=globalThis.URL.createObjectURL(a);WasmLoader.#V(s,r),setTimeout((()=>globalThis.URL.revokeObjectURL(s)),1e3)}static#V(e,r){const t=document.createElement('a');t.href=e,t.download=r,t.click()}}class CryptoJS{static RETURN_RAW=!0;static#r='Invalid alogrithm!';static#B='Invalid format';static#$='Unsupported operation!';static#M='Invalid key for algorithm';static#e='Invalid SHA-x';get crypto(){return globalThis.CryptoWasm.gc=!0,globalThis.CryptoWasm}get asRaw(){return!0===WasmLoader.RETURN_RAW}#G(e){if(e instanceof Uint8Array)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(e instanceof DataView)return new Uint8Array(e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength));if(e.buffer)return this.#G(e.buffer);throw new Error('Invalid data type!')}#p(e,r){if(r.indexOf(e)<0)throw new DOMException(CryptoJS.#B)}#l(e){return this.#p(e,['pkcs8','spki','raw'])}#F(e){switch(e){case'pkcs8':return!1;case'spki':case'raw':return!0;default:throw new TypeError(CryptoJS.#B)}}#z(e,r,t,a,s,n){this.#l(e);const i=this.#F(e),o=n.ImportKey(r,i);return new CryptoKeyJS(t,a,s,o)}#j(e,r,t,a,s){return this.#p(e,['raw']),new CryptoKeyJS(t,a,s,r)}#Y(e,r,t){let a=null;switch(e.length){case 128:case 192:case 256:a=this.crypto.random(e.length/8);break;default:throw new Error('Invalid AES key length!')}return new CryptoKeyJS(e,r,t,a)}#X(e,r,t){const a=e.length||CryptoKeyJS.blockSize(e.hash),s=this.crypto.random(a/8);return new CryptoKeyJS(e,r,t,s)}#q(e,r,t){let a=null;switch(e.modulusLength){case 1024:case 2048:case 4096:let r=0;e.publicExponent?.forEach((e=>r=(r<<8)+(255&e))),a=this.crypto.rsa.GenerateKey(e.modulusLength,r);break;default:throw new Error('Invalid modulus length')}let s=null,n=null;return'RSA-OAEP'===e.name?(s=['encrypt'],n=['decrypt']):(s=['verify'],n=['sign']),{publicKey:new CryptoKeyJS(e,r,s,a),privateKey:new CryptoKeyJS(e,r,n,a)}}#Q(e,r){const t=CryptoKeyJS.curveSize(e.namedCurve);return r.GenerateKey(t)}#Z(e,r,t,a){const s=this.#Q(e,a);return{publicKey:new CryptoKeyJS(e,r,['verify'],s),privateKey:new CryptoKeyJS(e,r,['sign'],s)}}#ee(e,r,t){const a=this,s='Ed25519'===e.namedCurve?a.crypto.ed25519:a.crypto.ecdsa;return a.#Z(e,r,t,s)}#re(e,r,t){const a=this.#Q(e,this.crypto.ecdh);return{publicKey:new CryptoKeyJS(e,r,[],a),privateKey:new CryptoKeyJS(e,r,t,a)}}#te(e,r){if((e.name||e)!=(r.algorithm.name||r.algorithm))throw new Error(CryptoJS.#M)}randomUUID(){const e=new Uint8Array(16);crypto.getRandomValues(e);const r=this.crypto.toHex(e).match(/.{2}/g);if('string'==typeof r?.error)throw new Error(r.error);return'xxxx-xx-xx-xx-xxxxxx'.split('').map((e=>'-'===e?e:r.pop())).join('')}async decrypt(e,r,t){const a=this;a.#te(e,r),t=a.#G(t);let s=e.iv||e.counter;s&&(s=a.#G(s));const n=(r.privateKey||r).decrypt(t,s);if('string'==typeof n?.error)throw new Error(n.error);return a.asRaw?n.buffer:n}async deriveBits(e,r,t){this.#te(e,r);const a=r.deriveBits(e,t);if('string'==typeof a?.error)throw new Error(a.error);return this.asRaw?a.buffer:a}async deriveKey(e,r,t,a,s){this.#te(e,r);const n=r.deriveKey(e,t,a,s);if('string'==typeof n?.error)throw new Error(n.error);return n}async digest(e,r){const t=this,a=t.crypto.hash;r=t.#G(r);let s=null;switch(e){case'SHA-1':s=a.Sha1(r);break;case'SHA-256':s=a.Sha256(r);break;case'SHA-384':s=a.Sha384(r);break;case'SHA-512':s=a.Sha512(r);break;default:throw new Error(CryptoJS.#e)}if('string'==typeof s?.error)throw new Error(s.error);return t.asRaw?s.buffer:s}async encrypt(e,r,t){const a=this;a.#te(e,r),t=a.#G(t);let s=e.iv||e.counter;s&&(s=a.#G(s));const n=(r.publicKey||r).encrypt(t,s);if('string'==typeof n?.error)throw new Error(n.error);return a.asRaw?n.buffer:n}async exportKey(e,r){const t=r.export(e);if('string'==typeof t?.error)throw new Error(t.error);return'jwk'===e?t:this.asRaw&&t.buffer||t}async generateKey(e,r,t){const a=this;let s=null;switch(e.name){case'Ed25519':case'ECDSA':s=a.#ee(e,r,t);break;case'X25519':case'ECDH':s=a.#re(e,r,t);break;case'RSASSA-PKCS1-v1_5':case'RSA-OAEP':case'RSA-PSS':s=a.#q(e,r,t);break;case'HMAC':s=a.#X(e,r,t);break;case'AES-CBC':case'AES-CTR':case'AES-GCM':s=a.#Y(e,r,t);break;default:throw new Error(CryptoJS.#r)}if('string'==typeof s?.error)throw new Error(s.error);return s}async importKey(e,r,t,a,s){const n=this;r=n.#G(r);const i=t.name||t,o=n.crypto;let c=null;switch(i){case'AES-CBC':case'AES-CTR':case'AES-GCM':case'HMAC':case'PBKDF2':case'HKDF':c=n.#j(e,r,t,a,s);break;case'RSASSA-PKCS1-v1_5':case'RSA-OAEP':case'RSA-PSS':c=n.#z(e,r,t,a,s,o.rsa);break;case'ECDSA':c=n.#z(e,r,t,a,s,o.ecdsa);break;case'ECDH':c=n.#z(e,r,t,a,s,o.ecdh);break;case'Ed25519':c=n.#z(e,r,t,a,s,o.ed25519);break;default:throw new Error(CryptoJS.#r)}if('string'==typeof c?.error)throw new Error(c.error);return c}async sign(e,r,t){const a=this;a.#te(e,r);const s=r.sign(a.#G(t),e);if('string'==typeof s?.error)throw new Error(s.error);return a.asRaw?s.buffer:s}async verify(e,r,t,a){const s=this;s.#te(e,r);const n=r.verify(s.#G(t),s.#G(a),e);if('string'==typeof n?.error)throw new Error(n.error);return n}async unwrapKey(e,r,t,a,s,n,i){throw new Error(CryptoJS.#$)}async wrapKey(e,r,t,a){throw new Error(CryptoJS.#$)}}export{CryptoJS,CryptoKeyJS,WasmLoader};
//# sourceMappingURL=io.greenscreens.cryptojs.min.js.map
